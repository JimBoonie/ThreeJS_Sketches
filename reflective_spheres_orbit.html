<!DOCTYPE html>
<head>
	<title>three.js - reflective spheres</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #eee;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/FBXLoader2.js"></script>
<script src="js/FresnelShader.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/HorseThreeHelpers.js"></script>

</body>
<script>
	var container;
	var container_id = "WebGL-Canvas";
	var scene, camera, renderer, light, controls;
	var spheres = [];
	var mouse = {x: 0, y: 0};
	
	var isMouseOverCanvas = false;
	var PI = Math.PI;
	var mouseSensitivity = 0.01;
	var sphereSpeed = 0.1;
	var sphereSpread = 400;
	var sphereYBounds = [-sphereSpread/2, sphereSpread/2];
	
	init();
	container.addEventListener('mouseover', onEventMouseOverCanvas, false);
	container.addEventListener('mouseout', onEventMouseLeftCanvas, false);
	container.addEventListener('mousemove', onEventGetMouseCoordinates, false);
	
	function init() {
		container = document.createElement('div');
		container.id = container_id;
		document.body.appendChild(container);
		
		camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 2000);
		camera.position.set(0, 0, 0);
		scene = new THREE.Scene();
		scene.fog = new THREE.Fog(0x000310, 1, 500);
		//scene.fog = new THREE.FogExp2(0x000310, 0.025);
		
		// assign background texture to scene
		/*var texture = new THREE.TextureLoader().load('assets/water.jpg');
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set( 4, 4 );
		scene.background = texture;*/
		
		// load seafloor
		var loadManager = HorseLoader();
		var loader = new THREE.FBXLoader(loadManager);
		loader.load('assets/seafloor.fbx', function(object) {
			var seafloor = object;
			seafloor.scale.set(sphereSpread/4, sphereSpread/4, sphereSpread/4);
			seafloor.position.y = -sphereSpread/2-50;
			scene.add(seafloor);
		}, loadManager.onProgress, loadManager.onError);
		
		// assign background cube
		var path = "assets/cubemaps/Tantolunden4/";
		var format = ".jpg";
		var urls = [ 
						path + 'posx' + format, path + 'negx' + format,
						path + 'posy' + format, path + 'negy' + format,
						path + 'posz' + format, path + 'negz' + format
					];
		var textureCube = new THREE.CubeTextureLoader().load(urls);
		textureCube.format = THREE.RGBFormat;
		//scene.background = textureCube;
		
		light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
		light.position.set(0, 1, 0);
		scene.add(light);
		
		// renderer
		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColor(0x000310);
		renderer.sortObjects = false;
		container.appendChild(renderer.domElement);

		// camera controls
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.target.set(0, 0, 1);
		controls.enableZoom = false;
		controls.enablePan = false;
		controls.update();
		
		// adding spheres
		var geometry = new THREE.SphereBufferGeometry( 10, 15, 15 );
		var n_spheres = 500;
		// iridescent shader material
		var shader = THREE.FresnelShader;
		var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
		uniforms["tCube"].value = textureCube;
		var material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader
		});
		for (i = 0; i < n_spheres; i++) {
			//let material = new THREE.MeshPhongMaterial({color: 0x00ddf7});
			var object = new THREE.Mesh(geometry, material);
			
			object.position.x = sphereSpread*(Math.random() - 0.5);
			object.position.y = sphereSpread*(Math.random() - 0.5);
			object.position.z = sphereSpread*(Math.random() - 0.5);
            
			let randScale = Math.random();
			object.scale.set(randScale + 0.5, randScale + 0.5, randScale + 0.5);
			object.trueScale = randScale;

			scene.add( object );
			spheres.push(object);
		}
		
		animate();
	}
	
	function onEventMouseOverCanvas() {
		isMouseOverCanvas = true;
	}
	
	function onEventMouseLeftCanvas() {
		isMouseOverCanvas = false;
	}
	
	function moveSpheres() {
		let timer = 0.001 * Date.now();
		
		for (let i = 0; i < spheres.length; i++) {
			let sphere = spheres[i];
			
			// change position
			sphere.position.x += 0.1*Math.sin(timer + i*1.1);
			sphere.position.y += sphereSpeed;
			
			// change size according to position
			let newScale = sphere.trueScale*(1 - Math.abs(sphere.position.y)/sphereYBounds[1]);
			sphere.scale.set(newScale, newScale, newScale);
			
			// clamp position to sphereYBounds
			if (sphere.position.y < sphereYBounds[0]) {
				sphere.position.y = sphereYBounds[1];
			} else if (sphere.position.y > sphereYBounds[1]) {
				sphere.position.y = sphereYBounds[0];
			}
		}
	}
	
	function animate() {
		requestAnimationFrame(animate);
		
		moveSpheres();
		
		renderer.render(scene, camera);
	}
</script>
</body>